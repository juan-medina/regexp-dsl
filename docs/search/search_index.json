{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RegExp DSL \u00b6 Expressive Regular Expressions with a Domain Specific Language written in Kotlin Info \u00b6 RegExp DSL is a library that allow the creation an usage of regular expressions, written in Kotlin, via a Domain Specif Language tha aims to be expressive. The overall idea is to make expressions easy to understand, modify and update. Installation \u00b6 Maven \u00b6 <dependency> <groupId> com.medina.juan </groupId> <artifactId> regexp-dsl </artifactId> <version> 1.0.0 </version> <type> bundle </type> </dependency> Gradle Groovy \u00b6 implementation 'com.medina.juan:regexp-dsl:1.0.0' Gradle Kotlin \u00b6 implementation ( \"com.medina.juan:regexp-dsl:1.0.0\" ) Usage \u00b6 Generating a RegExp \u00b6 import com.medina.juan.regexp.dsl.regexp fun main () { val reg = regexp { literal ( \"foo\" ) maybe ( \"bar\" ) zeroOrMore { character () } } println ( reg . matches ( \"foo\" )) // true println ( reg . matches ( \"fooooo\" )) // true println ( reg . matches ( \"foobar\" )) // true println ( reg . matches ( \"foobarrrr\" )) // true println ( reg . matches ( \"bar\" )) // false } Generating a pattern \u00b6 import com.medina.juan.regexp.dsl.pattern fun main () { val ptn = pattern { literal ( \"foo\" ) maybe ( \"bar\" ) zeroOrMore { character () } } println ( ptn ) // foo(?:bar)?.* } JSR Validations \u00b6 class ValidateName : DslValidator ({ literal ( \"foo\" ) maybe ( \"bar\" ) zeroOrMore { character () } }) @Constraint ( validatedBy = [ ValidateName :: class ]) annotation class ValidName ( val message : String = \"name is not valid\" , val groups : Array < KClass <*>> = [], val payload : Array < KClass <*>> = [] ) data class Person ( @field : ValidName val name : String ) License \u00b6 Copyright (C) 2020 Juan Medina Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Home"},{"location":"#regexp-dsl","text":"Expressive Regular Expressions with a Domain Specific Language written in Kotlin","title":"RegExp DSL"},{"location":"#info","text":"RegExp DSL is a library that allow the creation an usage of regular expressions, written in Kotlin, via a Domain Specif Language tha aims to be expressive. The overall idea is to make expressions easy to understand, modify and update.","title":"Info"},{"location":"#installation","text":"","title":"Installation"},{"location":"#maven","text":"<dependency> <groupId> com.medina.juan </groupId> <artifactId> regexp-dsl </artifactId> <version> 1.0.0 </version> <type> bundle </type> </dependency>","title":"Maven"},{"location":"#gradle-groovy","text":"implementation 'com.medina.juan:regexp-dsl:1.0.0'","title":"Gradle Groovy"},{"location":"#gradle-kotlin","text":"implementation ( \"com.medina.juan:regexp-dsl:1.0.0\" )","title":"Gradle Kotlin"},{"location":"#usage","text":"","title":"Usage"},{"location":"#generating-a-regexp","text":"import com.medina.juan.regexp.dsl.regexp fun main () { val reg = regexp { literal ( \"foo\" ) maybe ( \"bar\" ) zeroOrMore { character () } } println ( reg . matches ( \"foo\" )) // true println ( reg . matches ( \"fooooo\" )) // true println ( reg . matches ( \"foobar\" )) // true println ( reg . matches ( \"foobarrrr\" )) // true println ( reg . matches ( \"bar\" )) // false }","title":"Generating a RegExp"},{"location":"#generating-a-pattern","text":"import com.medina.juan.regexp.dsl.pattern fun main () { val ptn = pattern { literal ( \"foo\" ) maybe ( \"bar\" ) zeroOrMore { character () } } println ( ptn ) // foo(?:bar)?.* }","title":"Generating a pattern"},{"location":"#jsr-validations","text":"class ValidateName : DslValidator ({ literal ( \"foo\" ) maybe ( \"bar\" ) zeroOrMore { character () } }) @Constraint ( validatedBy = [ ValidateName :: class ]) annotation class ValidName ( val message : String = \"name is not valid\" , val groups : Array < KClass <*>> = [], val payload : Array < KClass <*>> = [] ) data class Person ( @field : ValidName val name : String )","title":"JSR Validations"},{"location":"#license","text":"Copyright (C) 2020 Juan Medina Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"examples/","text":"Examples \u00b6 Check an Url and get the domain \u00b6 import com.medina.juan.regexp.dsl.regexp fun main () { val urlCheck = regexp { line { literal ( \"http\" ) maybe ( \"s\" ) literal ( \"://\" ) group { oneOrMore { oneCharacterOf { alphaNumeric () character ( '-' ) character ( '.' ) } } character ( '.' ) repeat ( 2 , 3 ) { oneCharacterOf { alpha () } } } zeroOrMore { character () } } } if ( urlCheck . matches ( \"http://google.co.uk?q=foo\" )){ val domain = urlCheck . find ( case . url ) ?. groups ?. get ( 1 ) ?. value println ( domain ) //\"google.co.uk\" } }","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#check-an-url-and-get-the-domain","text":"import com.medina.juan.regexp.dsl.regexp fun main () { val urlCheck = regexp { line { literal ( \"http\" ) maybe ( \"s\" ) literal ( \"://\" ) group { oneOrMore { oneCharacterOf { alphaNumeric () character ( '-' ) character ( '.' ) } } character ( '.' ) repeat ( 2 , 3 ) { oneCharacterOf { alpha () } } } zeroOrMore { character () } } } if ( urlCheck . matches ( \"http://google.co.uk?q=foo\" )){ val domain = urlCheck . find ( case . url ) ?. groups ?. get ( 1 ) ?. value println ( domain ) //\"google.co.uk\" } }","title":"Check an Url and get the domain"},{"location":"api/regexp-dsl/","text":"regexp-dsl Packages \u00b6 Name Summary com.medina.juan.regexp.dsl Index \u00b6 All Types","title":"Home"},{"location":"api/regexp-dsl/#packages","text":"Name Summary com.medina.juan.regexp.dsl","title":"Packages"},{"location":"api/regexp-dsl/#index","text":"All Types","title":"Index"},{"location":"api/regexp-dsl/alltypes/","text":"All Types \u00b6 Name Summary com.medina.juan.regexp.dsl.DslElement \u00b6 | com.medina.juan.regexp.dsl.RegExValidator \u00b6","title":"Home"},{"location":"api/regexp-dsl/alltypes/#all-types","text":"Name Summary","title":"All Types"},{"location":"api/regexp-dsl/alltypes/#commedinajuanregexpdsldslelement","text":"|","title":"com.medina.juan.regexp.dsl.DslElement"},{"location":"api/regexp-dsl/alltypes/#commedinajuanregexpdslregexvalidator","text":"","title":"com.medina.juan.regexp.dsl.RegExValidator"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/","text":"regexp-dsl / com.medina.juan.regexp.dsl Package com.medina.juan.regexp.dsl \u00b6 Types \u00b6 Name Summary DslElement class DslElement RegExValidator open class RegExValidator : ConstraintValidator< Annotation , Any > Functions \u00b6 Name Summary pattern fun pattern(init: DslElement .() -> Unit ): String regexp fun regexp(init: DslElement .() -> Unit ): Regex","title":"API Documentation"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/#package-commedinajuanregexpdsl","text":"","title":"Package com.medina.juan.regexp.dsl"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/#types","text":"Name Summary DslElement class DslElement RegExValidator open class RegExValidator : ConstraintValidator< Annotation , Any >","title":"Types"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/#functions","text":"Name Summary pattern fun pattern(init: DslElement .() -> Unit ): String regexp fun regexp(init: DslElement .() -> Unit ): Regex","title":"Functions"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/pattern/","text":"regexp-dsl / com.medina.juan.regexp.dsl / pattern pattern \u00b6 fun pattern(init: DslElement .() -> Unit ): String","title":"Pattern"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/pattern/#pattern","text":"fun pattern(init: DslElement .() -> Unit ): String","title":"pattern"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/regexp/","text":"regexp-dsl / com.medina.juan.regexp.dsl / regexp regexp \u00b6 fun regexp(init: DslElement .() -> Unit ): Regex","title":"Regexp"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/regexp/#regexp","text":"fun regexp(init: DslElement .() -> Unit ): Regex","title":"regexp"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement DslElement \u00b6 class DslElement Constructors \u00b6 Name Summary <init> DslElement(before: String = \"\", after: String = \"\", children: DslElement .() -> Unit = empty) Functions \u00b6 Name Summary alpha fun alpha(): Unit alphaNumeric fun alphaNumeric(): Unit build fun build(): String character fun character(): Unit fun character(value: Char ): Unit group fun group(children: DslElement .() -> Unit ): Unit line fun line(children: DslElement .() -> Unit ): Unit literal fun literal(value: String ): Unit maybe fun maybe(literal: String = \"\"): Unit fun maybe(children: DslElement .() -> Unit = empty): Unit oneCharacterOf fun oneCharacterOf(children: DslElement .() -> Unit ): Unit oneOrMore fun oneOrMore(children: DslElement .() -> Unit = empty): Unit range fun range(from: Char , to: Char ): Unit repeat fun repeat(from: Int , to: Int = 0, children: DslElement .() -> Unit = empty): Unit zeroOrMore fun zeroOrMore(children: DslElement .() -> Unit = empty): Unit","title":"Home"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/#dslelement","text":"class DslElement","title":"DslElement"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/#constructors","text":"Name Summary <init> DslElement(before: String = \"\", after: String = \"\", children: DslElement .() -> Unit = empty)","title":"Constructors"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/#functions","text":"Name Summary alpha fun alpha(): Unit alphaNumeric fun alphaNumeric(): Unit build fun build(): String character fun character(): Unit fun character(value: Char ): Unit group fun group(children: DslElement .() -> Unit ): Unit line fun line(children: DslElement .() -> Unit ): Unit literal fun literal(value: String ): Unit maybe fun maybe(literal: String = \"\"): Unit fun maybe(children: DslElement .() -> Unit = empty): Unit oneCharacterOf fun oneCharacterOf(children: DslElement .() -> Unit ): Unit oneOrMore fun oneOrMore(children: DslElement .() -> Unit = empty): Unit range fun range(from: Char , to: Char ): Unit repeat fun repeat(from: Int , to: Int = 0, children: DslElement .() -> Unit = empty): Unit zeroOrMore fun zeroOrMore(children: DslElement .() -> Unit = empty): Unit","title":"Functions"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/-init-/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / <init> <init> \u00b6 DslElement(before: String = \"\", after: String = \"\", children: DslElement .() -> Unit = empty)","title":" init "},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/-init-/#init","text":"DslElement(before: String = \"\", after: String = \"\", children: DslElement .() -> Unit = empty)","title":"&lt;init&gt;"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/alpha-numeric/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / alphaNumeric alphaNumeric \u00b6 fun alphaNumeric(): Unit","title":"Alpha numeric"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/alpha-numeric/#alphanumeric","text":"fun alphaNumeric(): Unit","title":"alphaNumeric"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/alpha/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / alpha alpha \u00b6 fun alpha(): Unit","title":"Alpha"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/alpha/#alpha","text":"fun alpha(): Unit","title":"alpha"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/build/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / build build \u00b6 fun build(): String","title":"Build"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/build/#build","text":"fun build(): String","title":"build"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/character/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / character character \u00b6 fun character(): Unit fun character(value: Char ): Unit","title":"Character"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/character/#character","text":"fun character(): Unit fun character(value: Char ): Unit","title":"character"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/group/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / group group \u00b6 fun group(children: DslElement .() -> Unit ): Unit","title":"Group"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/group/#group","text":"fun group(children: DslElement .() -> Unit ): Unit","title":"group"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/line/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / line line \u00b6 fun line(children: DslElement .() -> Unit ): Unit","title":"Line"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/line/#line","text":"fun line(children: DslElement .() -> Unit ): Unit","title":"line"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/literal/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / literal literal \u00b6 fun literal(value: String ): Unit","title":"Literal"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/literal/#literal","text":"fun literal(value: String ): Unit","title":"literal"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/maybe/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / maybe maybe \u00b6 fun maybe(literal: String = \"\"): Unit fun maybe(children: DslElement .() -> Unit = empty): Unit","title":"Maybe"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/maybe/#maybe","text":"fun maybe(literal: String = \"\"): Unit fun maybe(children: DslElement .() -> Unit = empty): Unit","title":"maybe"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/one-character-of/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / oneCharacterOf oneCharacterOf \u00b6 fun oneCharacterOf(children: DslElement .() -> Unit ): Unit","title":"One character of"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/one-character-of/#onecharacterof","text":"fun oneCharacterOf(children: DslElement .() -> Unit ): Unit","title":"oneCharacterOf"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/one-or-more/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / oneOrMore oneOrMore \u00b6 fun oneOrMore(children: DslElement .() -> Unit = empty): Unit","title":"One or more"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/one-or-more/#oneormore","text":"fun oneOrMore(children: DslElement .() -> Unit = empty): Unit","title":"oneOrMore"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/range/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / range range \u00b6 fun range(from: Char , to: Char ): Unit","title":"Range"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/range/#range","text":"fun range(from: Char , to: Char ): Unit","title":"range"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/repeat/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / repeat repeat \u00b6 fun repeat(from: Int , to: Int = 0, children: DslElement .() -> Unit = empty): Unit","title":"Repeat"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/repeat/#repeat","text":"fun repeat(from: Int , to: Int = 0, children: DslElement .() -> Unit = empty): Unit","title":"repeat"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/zero-or-more/","text":"regexp-dsl / com.medina.juan.regexp.dsl / DslElement / zeroOrMore zeroOrMore \u00b6 fun zeroOrMore(children: DslElement .() -> Unit = empty): Unit","title":"Zero or more"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-dsl-element/zero-or-more/#zeroormore","text":"fun zeroOrMore(children: DslElement .() -> Unit = empty): Unit","title":"zeroOrMore"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/","text":"regexp-dsl / com.medina.juan.regexp.dsl / RegExValidator RegExValidator \u00b6 open class RegExValidator : ConstraintValidator< Annotation , Any > Constructors \u00b6 Name Summary <init> RegExValidator(init: DslElement .() -> Unit ) Functions \u00b6 Name Summary isValid open fun isValid(value: Any , context: ConstraintValidatorContext): Boolean","title":"Home"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/#regexvalidator","text":"open class RegExValidator : ConstraintValidator< Annotation , Any >","title":"RegExValidator"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/#constructors","text":"Name Summary <init> RegExValidator(init: DslElement .() -> Unit )","title":"Constructors"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/#functions","text":"Name Summary isValid open fun isValid(value: Any , context: ConstraintValidatorContext): Boolean","title":"Functions"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/-init-/","text":"regexp-dsl / com.medina.juan.regexp.dsl / RegExValidator / <init> <init> \u00b6 RegExValidator(init: DslElement .() -> Unit )","title":" init "},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/-init-/#init","text":"RegExValidator(init: DslElement .() -> Unit )","title":"&lt;init&gt;"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/is-valid/","text":"regexp-dsl / com.medina.juan.regexp.dsl / RegExValidator / isValid isValid \u00b6 open fun isValid(value: Any , context: ConstraintValidatorContext): Boolean","title":"Is valid"},{"location":"api/regexp-dsl/com.medina.juan.regexp.dsl/-reg-ex-validator/is-valid/#isvalid","text":"open fun isValid(value: Any , context: ConstraintValidatorContext): Boolean","title":"isValid"}]}